<!DOCTYPE html>
<html>
  <link rel="stylesheet" type="text/css" href="reader.css">
<head>
  <!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-9J1B2MTYSV"></script>
	<script>
 	 	window.dataLayer = window.dataLayer || [];
  	 	function gtag(){dataLayer.push(arguments);}
 	 	gtag('js', new Date());
 	 	gtag('config', 'G-9J1B2MTYSV');
	</script>
  <title> Workshop #1 - Article </title>
<meta name="viewport" content="width=device-width, initial-scale=1.5">
<style>

</style>
</head>
<body>

  <header id="navbar">
    <a href="index.html"><img src="blockchaintmu (normal logo - no background).png" alt="Welcome!" style="float:left;width:400px;height:220px;"></a>
          <div class="dropdown">
              <div class="dropdown-content">
                  <ul>
          <li><a href="index.html"><b>HOME</a></li></b>
          <li><a href="Workshops.html"><b>WORKSHOPS</a></li></b>
          <li><a href="FirstAccess.html"><b>FIRST/ACCESS</a></li></b>
          <li><a href="Columns.html"><b>ARTICLES</a></li></b>
                  </ul>
              </div>
              <div id="mySidenav" class="sidenav">
                <a href="Applications on the Blockchain (Part 1).html" id="about">WATCH VIDEO</a>
              </div>      
      </header>

<br><br><br><br><br><br><br><br><br><br><br><br><br>


<div class="button">
  <center><button class="paragraph-button" onclick="myFunction(); this.onclick=myFunction">Paragraph Mode</button></center>
  <center><button class="reader-button" onclick="myFunction1(); this.onclick=myFunction1">Reader Mode</button></center>
</div>
<br>


<div class="container">
<div id="myDIV">
    <br>
				<h1> The Fundamentals Within </h1>
				<h3> A Digital World of Blockchain </h3>
				<br>
        <p>
        Within the Web 3.0 space, apart from cryptocurrencies that are commonly discussed in the media, individual tokens are more or less considered opportunistic, separate from the financial value that the media deems to be important for. Specific to this, the kind of tokens in discussion are called "non-fungible" tokens, which are assets in the form of various digital or real-world assets, which typically include artwork, GIFs, videos, virtual avatars, in-game currencies, music, and more that cannot be substituted or subdivided. As they've gained popularity within the scene, this new format of digital art creation has provided opportunities for artists to showcase their work without having to undergo the struggles of having to so- to speak, create your own art show or video game in order to showcase them.				
        <br><br><br>
        In order to ensure that the movement of these non-fungible tokens do not spur traffic that may disrupt the creative process of these artists, there is a general process to how tokens of this kind are regulated, at which they are operated on behalf of something called 'tokenized standards'. These are set in place to encode metadata that can help to verify a particular asset to its appropriate owner. The setstone of these tokenized standards are largely reliant on the mint function of an NFT, which is meant to check the specifications of an assets metadata. Metadata is simply just data that make up of a file of some sort, which can involve hex values that generally involves color codes, titles and descriptions stored into a particular storage system called 'off-chain storage'. A lot of these processes which are focused on ensuring the uniformities of the assets, are dealt with a system at which they can be freely shared within a peer-to-peer network of the blockchain. Peer-to-peer networks depend largely on working within a 'decentralized' format, where unlike usual circumstances where your work is looked over by a potential organization within a central server (ex. Google), the focus of such networks are dealt within a situation where your work is managed privately under your own rules.  With decentralized servers, there is usually a file system that takes place, called an IPFS which stands for 'Interplanetary File System'. This file system is meant to assure that the assets are not interchangeable by transferring them from one system to another, which happens by combining metadata linked to earlier mentioned tokenized standards, in order to establish an automatic encoding process that stores information in an off-chain storage system at ease. These standards, specific to NFTs in common, go by the name ERC1155 and ERC721. To avoid complicating either of the two standards, we'll focus on explaining what the ERC1155 standard is meant to represent. As 'hex' values have been mentioned from before, this standard is essential in making use of fundamental functions such as a uint256 variable_id, which helps in defining fungible tokens by the ID of the owner for which it will be transferred from. Below is an algorithm that defines this standard, as well as the metadata that gets stored into an off-chain storage. As the person reading this might have different degrees of knowledge regarding what is seen below, I will only be showcasing the code and defining its simple elements.
				<br><br><br><i>
					// Algorithm 2: NFT Standard 1155
					interface IERC1155 
					{
					function balanceOf(address _owner, uint256 _id) external view returns (address);
					function transferFrom(address _from, address _to, uint256 _id, uint256 quantity) external payable
					}
				<br><br><br></i>
        This particular algorithm ensures that through functions such as 'transferFrom' and 'balanceOf', assets are externally traded between systems through an unsigned integer seen above as uint256, which is able to store non-negative integers. The number ‘256’ is a signifier of the SHA-256 algorithm, which is an algorithm responsible for currency exchanges done with Bitcoin. Non-negative integers are typically defined as numbers that can only be between zero or a positive value. In addition to this secure hash algorithm, which is what SHA stands for, ERC721 as mentioned before has similar qualities, but consists of scalability issues that belong to processes that usually involves compressing data that can save off-chain file storage in order to uncompress digital assets that spare a higher resolution for a particular asset which struggles to be distinguished. Generally speaking, these processes are what allow data to be stored and exchanged in certain ways, and will be further explained in future workshop content. Since the idea of standards is a relatively complex concept, further workshops will better explain the core concepts as they'll be broken down in explanations that fit the context of the standards usage. Regardless, the next important aspect of tokenized standards, are called flow standards, which is a protocol developed by Dapper Labs, created to be later implemented into processes that are otherwise deemed tedious when it comes to managing large sets of digital assets in a compressed data environment. Referring back to explaining the the sole structure of metadata, hex values are a commonly important element that is set to be in place for this algorithm seen below.
        <br><br><br>
				// Algorithm 3: Metadata file
					{
					"name": "Color",
					"hex": "#F08080",
					"link": "https://bit.ly/3mdRahT",
					"owner": "0x6902702BB5678D7361C94441c71F600C255dd833"
          }
				<br><br><br>
				The code above for the third showcased algorithm may come off as complex, but can be broken down into basic elements which are "name", "hex", "link", and "owner" ID, which are pieces of code that ensures to verify the ownership of a particular asset to its rightful owner. Mentioning the ERC721 protocol once more, this special standard behind is generally utilized by a major cryptocurrency exchange company by the name of Binance, which applies ERC721 to the Binance Smart Chain (BSC) therefore making it, BRC721. Similar in many ways, BRC721 allows content creators to tokenize the ownership of their assets and the data contained within it through a unique identifier, or DID (decentralized identifier), which applies a private key to a particular owner that can use it to prove or control their own identity. Similar to the algorithmic code behind ERC721, this one implements the code of totalSupply, which is defined by the 'total amount of coins or tokens of a specific cryptocurrency that have been created or mined, that are in circulation, including those that are locked or reserved.' Without unique identifiers, containing and preserving specific data can be difficult since the algorithms used to arrange the stored information cannot set data points to digital assets that are made up of different components, take it being a image for example.
				<br><br><br>
				As the tokenization of digital assets within the web 3.0 space ensures that there is regulated circulation of transactions in order to manage the economy under a regulatory system, past all of the implementations discussed so far, there are still issues that may arise regarding profits behind these rightful ownerships, as verifying them through the process of minting may create major hikes or dips in its value. Generally speaking, in the world of cryptocurrency, it is common for cryptographic tokens to have hikes and dips in value since it's not only based on the process of minting but also how much people talk about the currency. As opportunities do exist in digital spaces built in a decentralized environment, they are popularly hard to find considering that NFTs are an early project that was exposed too early to the masses. But despite all of this, another opportunity to combine these digital works within a collaborative space are done so through the metaverse, an online space set by Meta (known previously as Facebook), where content creators or explorers may make use of virtual or augmented reality headsets when given access to interacting with a three-dimensional streamline of world creations.
        <br><br><br>
        In every digital world that in its slightest is connected to the internet, there comes a set of layers like an onion, that helps to set the structure of the network-based infrastructure. As it would be a lengthy discussion to discuss all of them into depth, the base layers in the ideal context of blockchain technology are the human interface, infrastructure, and Internet of Things (IoT). Regarding the human interface, this layer is focused on sharing experiences between users of the world by helping to receive information useful in understanding the world through spatial computing, where the VR or AR headset can be used in visually understanding the digital space by associating it with the physical world. Adding onto human interface, other layers such as the infrastructure are essential in improving network connection technologies by using 5G and 6G, which can help with reducing the congestion of network bandwidth. In finality, the Internet of Things is identified as a layer in combining and constructing a 3D user interface that can help to associate the physical world with the digital one, by providing minimal effort for the user in making data-driven judgements that can assist organizations in understanding and utilizing the platforms that are built on the technology. Platforms that make use of IoT within the metaverse usually set up spaces such as virtual offices, where companies may hold meetings and such with selected avatars. Speaking of avatars, since users are required to create these as a digital identity, other AR or VR related processes are usually built into this technology on the blockchain, which takes user data based on their avatars to measure biometric psychography. As scientific as the term might be, it's a process that's used in the metaverse to measure user data emotions that are key in identifying concerns for privacy and data security, especially when it's within an algorithmic bias that functions outside of the physical world and is capable of identifying unintentional behavior. In other words, the metaverse is making use of AR technology to moderate virtual spaces to void any potential disruptions from taking place between virtual communications.
        <br><br><br>
        As every new piece of technology always has room for improvement, digital assets and spaces in particular can provide yet insist on building up environments that are open-source. Open-source, a widely popular term used to define something that's widely both accessible and shareable in a net space of programmable applications, is applicable to users within a global community that have the opportunity to suggest solutions that may allow others to move smoothly between various three-dimensional spaces in order to embody anything that involves an avatar and a virtual office with endless intercommunication. Though this is yet to be an improvement by large organizations, especially that of Facebook which has practically coined the word metaverse under a web 3.0 definition long after it was done in literature, industry partners and experts agree that such an ambitious concept requires a significant amount of work to be done. All of these implications and explanations come down to one question which involves the masses, how will we allow these transitions for a future generation that goes way past Web 3.0?
				<br><br><br><br><br><br>
				</p>
</div>

<div class="container">
<div id="myDIV1">
    <div class="article" id="article">
      <br>
      <h1> </h1>
      <h3> </h3>
      <br>
      <!-- <span class="tooltip" data-definition="" </span> !-->
      <p>
         This section is under construction.
      </p>                 

      <div class="tooltip-box" id="tooltipBox">
          <span id="tooltipContent"></span>
          <div class="video-container" id="videoContainer">
              <!-- Video recommendations will appear here -->
          </div>
          <span class="close-btn">×</span> <!-- Close button -->
      </div>
       
    </div>
    <div class="slider-container">
        <div class="arrow-button" id="prevButton">&#9650;</div>
        <p>
          <br><br><br><br>
          Paragraph <span id="currentParagraph">1</span> of <span id="totalParagraphs">24</span>
        </p>
        <div class="arrow-button" id="nextButton">&#9660;</div>
    </div>
</div>
</div>

<div class="tooltip-box" id="tooltipBox">
  <span id="tooltipContent"></span>
  <div class="video-container" id="videoContainer">
      <!-- Video recommendations will appear here -->
  </div>
  <span class="close-btn">×</span> <!-- Close button -->
</div>
</div>

<script>

function myFunction() {
  var x = document.getElementById("myDIV");
  var y = document.getElementById("myDIV1");
  if (x.style.display === "none") {
    x.style.display = "block";
  } else {
    x.style.display = "none";
  }
  if (y.style.display === "none") {
    y.style.display = "none";
  } else {
    y.style.display = "none";
  }
}

function myFunction1() {
  var x = document.getElementById("myDIV");
  var y = document.getElementById("myDIV1");
  if (x.style.display === "none") {
    x.style.display = "none";
  } else {
    x.style.display = "none";
  }
  if (y.style.display === "none") {
    y.style.display = "block";
  } else {
    y.style.display = "none";
  }
}

document.addEventListener('DOMContentLoaded', function() {
    const article = document.getElementById('article');
    const totalParagraphs = article.querySelectorAll('p').length;
    document.getElementById('totalParagraphs').textContent = totalParagraphs;

    let currentSlide = 1;
    let isTooltipDisplayed = false;

    function displayParagraph(slide) {
        const paragraphs = article.querySelectorAll('p');
        paragraphs.forEach(paragraph => {
            paragraph.style.opacity = '0';
        });

        const selectedParagraph = paragraphs[slide - 1];
        setTimeout(() => {
            selectedParagraph.style.opacity = '1';
        }, 100);

        document.getElementById('currentParagraph').textContent = slide;

        // Tooltip Functionality
        const tooltipSpan = selectedParagraph.querySelectorAll('.tooltip');
        const tooltipBox = document.createElement('div');
        tooltipBox.classList.add('tooltip-box');
        selectedParagraph.appendChild(tooltipBox);

        tooltipSpan.forEach(span => {
            span.addEventListener('click', (event) => {
                if (!isTooltipDisplayed) {
                    const definition = event.target.getAttribute('data-definition');
                    const videos = event.target.getAttribute('data-videos');

                    const tooltipContent = document.createElement('div');
                    tooltipContent.classList.add('tooltip-content');
                    tooltipContent.textContent = definition;

                    const videoContainer = document.createElement('div');
                    videoContainer.classList.add('video-container');
                    videoContainer.innerHTML = '';

                    if (videos) {
                        const videoList = videos.split(', ');
                        const videoListHTML = videoList.map(video => `<iframe width="100%" height="200" src="${video}" frameborder="0" allowfullscreen></iframe>`).join('');
                        videoContainer.innerHTML = `<h3>Video Recommendations:</h3>${videoListHTML}`;
                    }

                    tooltipBox.innerHTML = '';
                    tooltipBox.appendChild(tooltipContent);
                    tooltipBox.appendChild(videoContainer);

                    const closeBtn = document.createElement('span');
                    closeBtn.classList.add('close-btn');
                    closeBtn.textContent = 'X';
                    closeBtn.addEventListener('click', () => {
                        isTooltipDisplayed = false;
                        tooltipBox.style.display = 'none';
                    });
                    tooltipBox.appendChild(closeBtn);

                    tooltipBox.style.display = 'block';
                    isTooltipDisplayed = true;


                }
            });

            tooltipBox.removeEventListener('mouseleave', () => {
                isTooltipDisplayed = false;
                tooltipBox.style.display = 'none';
            });
        });
    }

    document.getElementById('nextButton').addEventListener('click', () => {
        if (currentSlide < totalParagraphs) {
            currentSlide++;
            displayParagraph(currentSlide);
        }
    });

    document.getElementById('prevButton').addEventListener('click', () => {
        if (currentSlide > 1) {
            currentSlide--;
            displayParagraph(currentSlide);
        }
    });

    displayParagraph(currentSlide);
});

let prevScrollPos = window.pageYOffset;

    window.onscroll = function() {
      let currentScrollPos = window.pageYOffset;

      if (prevScrollPos > currentScrollPos) {
        document.getElementById("navbar").classList.remove("hidden");
      } else {
        document.getElementById("navbar").classList.add("hidden");
      }

      prevScrollPos = currentScrollPos;
    };

    // JavaScript to bring back solidity on hover
    const navbar = document.getElementById('navbar');

    navbar.addEventListener('mouseenter', function() {
      navbar.classList.remove('hidden');
    });

    navbar.addEventListener('mouseleave', function() {
      if (window.scrollY === 0) {
        navbar.classList.add('hidden');
      }
    });


</script>

</body>
</html>

